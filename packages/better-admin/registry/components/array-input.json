{
	"name": "array-input",
	"type": "components:ui",
	"category": "forms",
	"description": "Input for array/list data",
	"dependencies": {
		"shadcn": ["form", "input", "label", "button"],
		"npm": []
	},
	"registryDependencies": [],
	"files": [
		{
			"path": "components/admin/array-input.tsx",
			"content": "import {\n  FieldTitle,\n  InputProps,\n  OptionalResourceContextProvider,\n  SourceContextProvider,\n  type SourceContextValue,\n  composeSyncValidators,\n  isRequired,\n  useApplyInputDefaultValues,\n  useFormGroupContext,\n  useFormGroups,\n  useGetValidationErrorMessage,\n  useSourceContext,\n  sanitizeInputRestProps,\n  ArrayInputContext,\n} from \"ra-core\";\nimport * as React from \"react\";\nimport { useEffect } from \"react\";\nimport { useFieldArray, useFormContext } from \"react-hook-form\";\n\nimport { Label } from \"@/components/ui/label\";\nimport { cn } from \"@/lib/utils\";\nimport { Skeleton } from \"../ui/skeleton\";\nimport { InputHelperText } from \"@/components/admin/input-helper-text\";\nimport { FormError, FormField } from \"@/components/admin/form\";\n\nexport const ArrayInput = (props: ArrayInputProps) => {\n  const {\n    className,\n    defaultValue = [],\n    label,\n    isPending,\n    children,\n    helperText,\n    resource: resourceFromProps,\n    source: arraySource,\n    validate,\n    ...rest\n  } = props;\n\n  const formGroupName = useFormGroupContext();\n  const formGroups = useFormGroups();\n  const parentSourceContext = useSourceContext();\n  const finalSource = parentSourceContext.getSource(arraySource);\n\n  const sanitizedValidate = Array.isArray(validate)\n    ? composeSyncValidators(validate)\n    : validate;\n  const getValidationErrorMessage = useGetValidationErrorMessage();\n\n  const { getValues } = useFormContext();\n\n  const fieldProps = useFieldArray({\n    name: finalSource,\n    rules: {\n      validate: async (value) => {\n        if (!sanitizedValidate) return true;\n        const error = await sanitizedValidate(value, getValues(), props);\n\n        if (!error) return true;\n        return getValidationErrorMessage(error);\n      },\n    },\n  });\n\n  useEffect(() => {\n    if (formGroups && formGroupName != null) {\n      formGroups.registerField(finalSource, formGroupName);\n    }\n\n    return () => {\n      if (formGroups && formGroupName != null) {\n        formGroups.unregisterField(finalSource, formGroupName);\n      }\n    };\n  }, [finalSource, formGroups, formGroupName]);\n\n  useApplyInputDefaultValues({\n    inputProps: { ...props, defaultValue },\n    isArrayInput: true,\n    fieldArrayInputControl: fieldProps,\n  });\n\n  // The SourceContext will be read by children of ArrayInput to compute their composed source and label\n  //\n  // <ArrayInput source=\"orders\" /> => SourceContext is \"orders\"\n  //   <SimpleFormIterator> => SourceContext is \"orders.0\"\n  //     <DateInput source=\"date\" /> => final source for this input will be \"orders.0.date\"\n  //   </SimpleFormIterator>\n  // </ArrayInput>\n  //\n  const sourceContext = React.useMemo<SourceContextValue>(\n    () => ({\n      // source is the source of the ArrayInput child\n      getSource: (source: string) => {\n        if (!source) {\n          // SimpleFormIterator calls getSource('') to get the arraySource\n          return parentSourceContext.getSource(arraySource);\n        }\n\n        // We want to support nesting and composition with other inputs (e.g. TranslatableInputs, ReferenceOneInput, etc),\n        // we must also take into account the parent SourceContext\n        //\n        // <ArrayInput source=\"orders\" /> => SourceContext is \"orders\"\n        //   <SimpleFormIterator> => SourceContext is \"orders.0\"\n        //      <DateInput source=\"date\" /> => final source for this input will be \"orders.0.date\"\n        //      <ArrayInput source=\"items\" /> => SourceContext is \"orders.0.items\"\n        //          <SimpleFormIterator> => SourceContext is \"orders.0.items.0\"\n        //              <TextInput source=\"reference\" /> => final source for this input will be \"orders.0.items.0.reference\"\n        //          </SimpleFormIterator>\n        //      </ArrayInput>\n        //   </SimpleFormIterator>\n        // </ArrayInput>\n        return parentSourceContext.getSource(`${arraySource}.${source}`);\n      },\n      // if Array source is items, and child source is name, .0.name => resources.orders.fields.items.name\n      getLabel: (source: string) =>\n        parentSourceContext.getLabel(`${arraySource}.${source}`),\n    }),\n    [parentSourceContext, arraySource],\n  );\n\n  if (isPending) {\n    return <Skeleton className=\"w-full h-9\" />;\n  }\n\n  return (\n    <FormField\n      className={cn(\n        \"ra-input\",\n        `ra-input-${finalSource}`,\n        className,\n        \"w-full flex flex-col gap-2\",\n      )}\n      name={finalSource}\n      {...sanitizeInputRestProps(rest)}\n    >\n      <Label className=\"text-muted-foreground text-sm\">\n        <FieldTitle\n          label={label}\n          source={arraySource}\n          resource={resourceFromProps}\n          isRequired={isRequired(validate)}\n        />\n      </Label>\n      <ArrayInputContext.Provider value={fieldProps}>\n        <OptionalResourceContextProvider value={resourceFromProps}>\n          <SourceContextProvider value={sourceContext}>\n            {children}\n          </SourceContextProvider>\n        </OptionalResourceContextProvider>\n      </ArrayInputContext.Provider>\n\n      <InputHelperText helperText={helperText} />\n      <FormError />\n    </FormField>\n  );\n};\n\nexport interface ArrayInputProps\n  extends Omit<InputProps, \"disabled\" | \"readOnly\"> {\n  className?: string;\n  children: React.ReactNode;\n  isFetching?: boolean;\n  isLoading?: boolean;\n  isPending?: boolean;\n}\n",
			"type": "components:ui"
		}
	],
	"tailwind": {
		"config": {}
	}
}
