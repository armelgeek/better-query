{
  "name": "select-input",
  "type": "components:ui",
  "category": "forms",
  "description": "Dropdown select input",
  "dependencies": {
    "shadcn": [
      "form",
      "input",
      "label",
      "button"
    ],
    "npm": []
  },
  "registryDependencies": [],
  "files": [
    {
      "path": "components/admin/select-input.tsx",
      "content": "import { X } from \"lucide-react\";\nimport {\n  FieldTitle,\n  InputProps,\n  useChoices,\n  useChoicesContext,\n  useGetRecordRepresentation,\n  useInput,\n  useTranslate,\n  type ChoicesProps,\n} from \"ra-core\";\nimport {\n  ComponentProps,\n  useCallback,\n  useEffect,\n  type ReactElement,\n} from \"react\";\n\nimport { FormError, FormField, FormLabel } from \"@/components/admin/form\";\nimport { InputHelperText } from \"@/components/admin/input-helper-text\";\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from \"@/components/ui/select\";\nimport { Skeleton } from \"@/components/ui/skeleton\";\nimport {\n  SupportCreateSuggestionOptions,\n  useSupportCreateSuggestion,\n} from \"@/hooks/useSupportCreateSuggestion\";\nimport { cn } from \"@/lib/utils\";\n\nexport const SelectInput = (props: SelectInputProps) => {\n  const {\n    choices: choicesProp,\n    isLoading: isLoadingProp,\n    isFetching: isFetchingProp,\n    isPending: isPendingProp,\n    resource: resourceProp,\n    source: sourceProp,\n\n    optionText,\n    optionValue,\n    disableValue = \"disabled\",\n    translateChoice,\n    createValue,\n    createHintValue,\n\n    alwaysOn,\n    defaultValue,\n    format,\n    label,\n    helperText,\n    name,\n    onBlur,\n    onChange,\n    parse,\n    validate,\n    readOnly,\n    disabled,\n\n    className,\n    emptyText = \"\",\n    emptyValue = \"\",\n    filter: _filter,\n    create,\n    createLabel,\n    onCreate,\n\n    ...rest\n  } = props;\n  const translate = useTranslate();\n\n  useEffect(() => {\n    if (emptyValue == null) {\n      throw new Error(\n        `emptyValue being set to null or undefined is not supported. Use parse to turn the empty string into null.`,\n      );\n    }\n  }, [emptyValue]);\n\n  const {\n    allChoices,\n    isPending,\n    error: fetchError,\n    source,\n    resource,\n    isFromReference,\n  } = useChoicesContext({\n    choices: choicesProp,\n    isLoading: isLoadingProp,\n    isFetching: isFetchingProp,\n    isPending: isPendingProp,\n    resource: resourceProp,\n    source: sourceProp,\n  });\n\n  if (source === undefined) {\n    throw new Error(\n      `If you're not wrapping the SelectInput inside a ReferenceInput, you must provide the source prop`,\n    );\n  }\n\n  if (!isPending && !fetchError && allChoices === undefined) {\n    throw new Error(\n      `If you're not wrapping the SelectInput inside a ReferenceInput, you must provide the choices prop`,\n    );\n  }\n\n  const getRecordRepresentation = useGetRecordRepresentation(resource);\n  const { getChoiceText, getChoiceValue, getDisableValue } = useChoices({\n    optionText:\n      optionText ?? (isFromReference ? getRecordRepresentation : undefined),\n    optionValue,\n    disableValue,\n    translateChoice: translateChoice ?? !isFromReference,\n    createValue,\n    createHintValue,\n  });\n  const { id, field, isRequired } = useInput({\n    alwaysOn,\n    defaultValue,\n    format,\n    label,\n    helperText,\n    name,\n    onBlur,\n    onChange,\n    parse,\n    resource,\n    source,\n    validate,\n    readOnly,\n    disabled,\n  });\n\n  const renderEmptyItemOption = useCallback(() => {\n    return typeof emptyText === \"string\"\n      ? emptyText === \"\"\n        ? \"â€ƒ\" // em space, forces the display of an empty line of normal height\n        : translate(emptyText, { _: emptyText })\n      : emptyText;\n  }, [emptyText, translate]);\n\n  const renderMenuItemOption = useCallback(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    (choice: any) => getChoiceText(choice),\n    [getChoiceText],\n  );\n\n  const handleChange = useCallback(\n    async (value: string) => {\n      if (value === emptyValue) {\n        field.onChange(emptyValue);\n      } else {\n        // Find the choice by value and pass it to field.onChange\n        const choice = allChoices?.find(\n          (choice) => getChoiceValue(choice) === value,\n        );\n        field.onChange(choice ? getChoiceValue(choice) : value);\n      }\n    },\n    [field, getChoiceValue, emptyValue, allChoices],\n  );\n\n  const {\n    getCreateItem,\n    handleChange: handleChangeWithCreateSupport,\n    createElement,\n  } = useSupportCreateSuggestion({\n    create,\n    createLabel,\n    createValue,\n    createHintValue,\n    onCreate,\n    handleChange,\n    optionText,\n  });\n\n  if (isPending) {\n    return (\n      <FormField\n        id={id}\n        name={field.name}\n        className={cn(\"w-full min-w-20\", className)}\n      >\n        {label !== \"\" && label !== false && (\n          <FormLabel>\n            <FieldTitle\n              label={label}\n              source={source}\n              resource={resourceProp}\n              isRequired={isRequired}\n            />\n          </FormLabel>\n        )}\n        <div className=\"relative\">\n          <Skeleton className=\"w-full h-9\" />\n        </div>\n        <InputHelperText helperText={helperText} />\n        <FormError />\n      </FormField>\n    );\n  }\n\n  const createItem = create || onCreate ? getCreateItem() : null;\n  let finalChoices = fetchError ? [] : allChoices;\n  if (create || onCreate) {\n    finalChoices = [...finalChoices, createItem];\n  }\n\n  // Handle reset functionality\n  const handleReset = (e: React.MouseEvent<HTMLDivElement>) => {\n    e.stopPropagation();\n    field.onChange(emptyValue);\n  };\n\n  return (\n    <>\n      <FormField\n        id={id}\n        name={field.name}\n        className={cn(\"w-full min-w-20\", className)}\n        {...rest}\n      >\n        {label !== \"\" && label !== false && (\n          <FormLabel>\n            <FieldTitle\n              label={label}\n              source={source}\n              resource={resourceProp}\n              isRequired={isRequired}\n            />\n          </FormLabel>\n        )}\n        <div className=\"relative\">\n          <Select\n            //FIXME https://github.com/radix-ui/primitives/issues/3135\n            // Setting a key based on the value fixes an issue where onValueChange\n            // was called with an empty string when the controlled value was changed.\n            // See: https://github.com/radix-ui/primitives/issues/3135#issuecomment-2916908248\n            key={`select:${field.value?.toString() ?? emptyValue}`}\n            value={field.value?.toString() || emptyValue}\n            onValueChange={handleChangeWithCreateSupport}\n          >\n            <SelectTrigger\n              className={cn(\"w-full transition-all hover:bg-accent\")}\n              disabled={field.disabled}\n            >\n              <SelectValue placeholder={renderEmptyItemOption()} />\n\n              {field.value && field.value !== emptyValue ? (\n                <div\n                  role=\"button\"\n                  className=\"p-0 ml-auto pointer-events-auto hover:bg-transparent text-muted-foreground opacity-50 hover:opacity-100\"\n                  onClick={handleReset}\n                >\n                  <X className=\"h-4 w-4\" />\n                </div>\n              ) : null}\n            </SelectTrigger>\n            <SelectContent>\n              {finalChoices?.map((choice) => {\n                if (!choice) return null;\n                const value = getChoiceValue(choice);\n                const isDisabled = getDisableValue(choice);\n\n                return (\n                  <SelectItem\n                    key={value}\n                    value={value?.toString()}\n                    disabled={isDisabled}\n                  >\n                    {renderMenuItemOption(\n                      !!createItem && choice?.id === createItem.id\n                        ? createItem\n                        : choice,\n                    )}\n                  </SelectItem>\n                );\n              })}\n            </SelectContent>\n          </Select>\n        </div>\n        <InputHelperText helperText={helperText} />\n      </FormField>\n      {createElement}\n    </>\n  );\n};\n\nexport type SelectInputProps = ChoicesProps &\n  // Source is optional as SelectInput can be used inside a ReferenceInput that already defines the source\n  Partial<InputProps> &\n  Omit<SupportCreateSuggestionOptions, \"handleChange\"> & {\n    emptyText?: string | ReactElement;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    emptyValue?: any;\n    onChange?: (value: string) => void;\n  } & Omit<ComponentProps<typeof FormField>, \"id\" | \"name\" | \"children\">;\n",
      "type": "components:ui"
    }
  ],
  "tailwind": {
    "config": {}
  }
}