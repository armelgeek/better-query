{
	"name": "reference-array-field",
	"type": "components:ui",
	"category": "fields",
	"description": "Display multiple related records",
	"dependencies": {
		"shadcn": ["card"],
		"npm": []
	},
	"registryDependencies": [],
	"files": [
		{
			"path": "components/admin/reference-array-field.tsx",
			"content": "import { memo, type ReactElement, type ReactNode } from \"react\";\nimport {\n  ExtractRecordPaths,\n  HintedString,\n  ReferenceArrayFieldBase,\n  useListContext,\n  type FilterPayload,\n  type ListControllerResult,\n  type RaRecord,\n  type SortPayload,\n} from \"ra-core\";\nimport type { UseQueryOptions } from \"@tanstack/react-query\";\nimport { SingleFieldList } from \"@/components/admin/single-field-list\";\n\n/**\n * A container component that fetches records from another resource specified\n * by an array of *ids* in current record.\n *\n * You must define the fields to be passed to the iterator component as children.\n *\n * @example Display all the categories of the current product as a list of chips (the default)\n * // product = {\n * //   id: 456,\n * //   category_ids: [11, 22, 33],\n * // }\n * <ReferenceArrayField label=\"Categories\" reference=\"categories\" source=\"category_ids\"/ >\n *\n * @example Display all the products of the current order as DataTable\n * // order = {\n * //   id: 123,\n * //   product_ids: [456, 457, 458],\n * // }\n * <ReferenceArrayField label=\"Products\" reference=\"products\" source=\"product_ids\">\n *     <DataTable>\n *         <DataTable.Col source=\"id\" />\n *         <DataTable.Col source=\"description\" />\n *         <DataTable.NumberCol source=\"price\" options={{ style: 'currency', currency: 'USD' }} />\n *         <DataTable.Col><EditButton /></DataTable.Col>\n *     </DataTable>\n * </ReferenceArrayField>\n *\n * By default, restricts the displayed values to 1000. You can extend this limit\n * by setting the `perPage` prop.\n *\n * @example\n * <ReferenceArrayField perPage={10} reference=\"categories\" source=\"category_ids\">\n *    ...\n * </ReferenceArrayField>\n *\n * By default, the field displays the results in the order in which they are referenced\n * (i.e. in the order of the list of ids). You can change this order\n * by setting the `sort` prop (an object with `field` and `order` properties).\n *\n * @example\n * <ReferenceArrayField sort={{ field: 'name', order: 'ASC' }} reference=\"categories\" source=\"category_ids\">\n *    ...\n * </ReferenceArrayField>\n *\n * Also, you can filter the results to display only a subset of values. Use the\n * `filter` prop for that.\n *\n * @example\n * <ReferenceArrayField filter={{ is_published: true }} reference=\"categories\" source=\"category_ids\">\n *    ...\n * </ReferenceArrayField>\n */\nexport const ReferenceArrayField = <\n  RecordType extends RaRecord = RaRecord,\n  ReferenceRecordType extends RaRecord = RaRecord,\n>(\n  props: ReferenceArrayFieldProps<RecordType, ReferenceRecordType>,\n) => {\n  const {\n    filter,\n    page = 1,\n    perPage,\n    reference,\n    resource,\n    sort,\n    source,\n    queryOptions,\n    render,\n    ...rest\n  } = props;\n  return (\n    <ReferenceArrayFieldBase\n      filter={filter}\n      page={page}\n      perPage={perPage}\n      reference={reference}\n      resource={resource}\n      sort={sort}\n      source={source}\n      queryOptions={queryOptions}\n      render={render}\n    >\n      <PureReferenceArrayFieldView {...rest} />\n    </ReferenceArrayFieldBase>\n  );\n};\nexport interface ReferenceArrayFieldProps<\n  RecordType extends RaRecord = RaRecord,\n  ReferenceRecordType extends RaRecord = RaRecord,\n> extends ReferenceArrayFieldViewProps {\n  filter?: FilterPayload;\n  page?: number;\n  pagination?: ReactElement;\n  perPage?: number;\n  reference: string;\n  resource?: string;\n  source: NoInfer<HintedString<ExtractRecordPaths<RecordType>>>;\n  sort?: SortPayload;\n  queryOptions?: Omit<\n    UseQueryOptions<ReferenceRecordType[], Error>,\n    \"queryFn\" | \"queryKey\"\n  >;\n  render?: (props: ListControllerResult<ReferenceRecordType>) => ReactElement;\n}\n\nexport interface ReferenceArrayFieldViewProps {\n  children?: ReactNode;\n  className?: string;\n  empty?: ReactNode;\n  error?: ReactNode;\n  loading?: ReactNode;\n  pagination?: ReactNode;\n}\n\nexport const ReferenceArrayFieldView = (\n  props: ReferenceArrayFieldViewProps,\n) => {\n  const {\n    children = defaultChildren,\n    className,\n    empty,\n    error: errorElement,\n    loading,\n    pagination,\n  } = props;\n  const {\n    isPending,\n    error,\n    total,\n    hasPreviousPage,\n    hasNextPage,\n    data,\n    filterValues,\n  } = useListContext();\n\n  return (\n    <div className={className}>\n      {isPending && loading !== false ? (\n        loading\n      ) : error && errorElement !== false ? (\n        errorElement\n      ) : (total === 0 ||\n          (total == null &&\n            hasPreviousPage === false &&\n            hasNextPage === false &&\n            // @ts-expect-error FIXME total may be undefined when using partial pagination but the ListControllerResult type is wrong about it\n            data.length === 0 &&\n            // the user didn't set any filters\n            !Object.keys(filterValues).length)) &&\n        empty !== false ? (\n        empty\n      ) : (\n        <span>\n          {children}\n          {pagination && total !== undefined ? pagination : null}\n        </span>\n      )}\n    </div>\n  );\n};\n\nconst defaultChildren = <SingleFieldList />;\nconst PureReferenceArrayFieldView = memo(ReferenceArrayFieldView);\n",
			"type": "components:ui"
		}
	],
	"tailwind": {
		"config": {}
	}
}
