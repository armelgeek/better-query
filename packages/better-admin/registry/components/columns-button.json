{
	"name": "columns-button",
	"type": "components:ui",
	"category": "buttons",
	"description": "Button to toggle column visibility",
	"dependencies": {
		"shadcn": ["button", "tooltip"],
		"npm": []
	},
	"registryDependencies": [],
	"files": [
		{
			"path": "components/admin/columns-button.tsx",
			"content": "import {\n  useState,\n  useEffect,\n  Children,\n  type ComponentProps,\n  type ReactNode,\n} from \"react\";\nimport { createPortal } from \"react-dom\";\n// eslint-disable-next-line @typescript-eslint/ban-ts-comment\n// @ts-ignore\nimport * as diacritic from \"diacritic\";\nimport {\n  useDataTableStoreContext,\n  useStore,\n  useTranslate,\n  useResourceContext,\n  useDataTableColumnRankContext,\n  useDataTableColumnFilterContext,\n  useTranslateLabel,\n  DataTableColumnRankContext,\n  DataTableColumnFilterContext,\n  type RaRecord,\n  type Identifier,\n  type SortPayload,\n  type HintedString,\n  type ExtractRecordPaths,\n} from \"ra-core\";\nimport { Columns, Search } from \"lucide-react\";\nimport * as PopoverPrimitive from \"@radix-ui/react-popover\";\nimport { useIsMobile } from \"@/hooks/use-mobile\";\nimport { Button } from \"@/components/ui/button\";\nimport { Input } from \"@/components/ui/input\";\nimport { FieldToggle } from \"@/components/admin/field-toggle\";\nimport {\n  Tooltip,\n  TooltipContent,\n  TooltipTrigger,\n} from \"@/components/ui/tooltip\";\nimport { Popover, PopoverTrigger } from \"@/components/ui/popover\";\nimport { cn } from \"@/lib/utils\";\n\n/**\n * Renders a button that lets users show / hide columns in a DataTable\n *\n * @example\n * import { ColumnsButton, DataTable } from 'shadcn-admin-kit';\n *\n * const PostListActions = () => (\n *   <div className=\"flex items-center gap-2\">\n        <ColumnsButton />\n        <FilterButton />\n *   </div>\n * );\n *\n * const PostList = () => (\n *   <List actions={<PostListActions />}>\n *     <DataTable>\n *       <DataTable.Col source=\"title\" />\n *       <DataTable.Col source=\"author\" />\n         ...\n *     </DataTable>\n *   </List>\n * );\n */\nexport const ColumnsButton = (props: ColumnsButtonProps) => {\n  const { className, storeKey: _, ...rest } = props;\n  const resource = useResourceContext(props);\n  const storeKey = props.storeKey || `${resource}.datatable`;\n\n  const [open, setOpen] = useState(false);\n  const isMobile = useIsMobile();\n  const translate = useTranslate();\n\n  const title = translate(\"ra.action.select_columns\", { _: \"Columns\" });\n\n  return (\n    <span className={cn(\"inline-flex\", className)}>\n      <Popover open={open} onOpenChange={setOpen}>\n        <PopoverTrigger asChild>\n          {isMobile ? (\n            <Tooltip>\n              <TooltipTrigger asChild>\n                <Button\n                  variant=\"ghost\"\n                  size=\"icon\"\n                  aria-label={title}\n                  {...rest}\n                >\n                  <Columns className=\"size-4\" />\n                </Button>\n              </TooltipTrigger>\n              <TooltipContent>{title}</TooltipContent>\n            </Tooltip>\n          ) : (\n            <Button variant=\"outline\" className=\"cursor-pointer\" {...rest}>\n              <Columns />\n              {title}\n            </Button>\n          )}\n        </PopoverTrigger>\n        <PopoverPrimitive.Portal forceMount>\n          <div className={open ? \"block\" : \"hidden\"}>\n            <PopoverPrimitive.Content\n              data-slot=\"popover-content\"\n              sideOffset={4}\n              align=\"start\"\n              className=\"bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-72 origin-(--radix-popover-content-transform-origin) rounded-md border shadow-md outline-hidden p-0 min-w-[200px]\"\n            >\n              <div id={`${storeKey}-columnsSelector`} className=\"p-2\" />\n            </PopoverPrimitive.Content>\n          </div>\n        </PopoverPrimitive.Portal>\n      </Popover>\n    </span>\n  );\n};\n\nexport interface ColumnsButtonProps extends ComponentProps<typeof Button> {\n  resource?: string;\n  storeKey?: string;\n}\n\n/**\n * Render DataTable.Col elements in the ColumnsButton selector using a React Portal.\n *\n * @see ColumnsButton\n */\nexport const ColumnsSelector = ({ children }: ColumnsSelectorProps) => {\n  const translate = useTranslate();\n  const { storeKey, defaultHiddenColumns } = useDataTableStoreContext();\n  const [columnRanks, setColumnRanks] = useStore<number[] | undefined>(\n    `${storeKey}_columnRanks`,\n  );\n  const [_hiddenColumns, setHiddenColumns] = useStore<string[]>(\n    storeKey,\n    defaultHiddenColumns,\n  );\n  const elementId = `${storeKey}-columnsSelector`;\n\n  const [container, setContainer] = useState<HTMLElement | null>(() =>\n    typeof document !== \"undefined\" ? document.getElementById(elementId) : null,\n  );\n\n  // on first mount, we don't have the container yet, so we wait for it\n  useEffect(() => {\n    if (\n      container &&\n      typeof document !== \"undefined\" &&\n      document.body.contains(container)\n    )\n      return;\n    // look for the container in the DOM every 100ms\n    const interval = setInterval(() => {\n      const target = document.getElementById(elementId);\n      if (target) setContainer(target);\n    }, 100);\n    // stop looking after 500ms\n    const timeout = setTimeout(() => clearInterval(interval), 500);\n    return () => {\n      clearInterval(interval);\n      clearTimeout(timeout);\n    };\n  }, [elementId, container]);\n\n  const [columnFilter, setColumnFilter] = useState<string>(\"\");\n\n  if (!container) return null;\n\n  const childrenArray = Children.toArray(children);\n  const paddedColumnRanks = padRanks(columnRanks ?? [], childrenArray.length);\n  const shouldDisplaySearchInput = childrenArray.length > 5;\n\n  return createPortal(\n    <ul className=\"max-h-[50vh] p-1 overflow-auto\">\n      {shouldDisplaySearchInput ? (\n        <li className=\"pb-2\" tabIndex={-1}>\n          <div className=\"relative\">\n            <Input\n              value={columnFilter}\n              onChange={(e: React.ChangeEvent<HTMLInputElement>) => {\n                setColumnFilter(e.target.value);\n              }}\n              placeholder={translate(\"ra.action.search_columns\", {\n                _: \"Search columns\",\n              })}\n              className=\"pr-8\"\n            />\n            <Search className=\"absolute right-2 top-2 h-4 w-4 text-muted-foreground\" />\n            {columnFilter && (\n              <button\n                onClick={() => setColumnFilter(\"\")}\n                className=\"absolute right-8 top-2 h-4 w-4 text-muted-foreground\"\n                aria-label=\"Clear\"\n              >\n                Ã—\n              </button>\n            )}\n          </div>\n        </li>\n      ) : null}\n      {paddedColumnRanks.map((position, index) => (\n        <DataTableColumnRankContext.Provider value={position} key={index}>\n          <DataTableColumnFilterContext.Provider\n            value={columnFilter}\n            key={index}\n          >\n            {childrenArray[position]}\n          </DataTableColumnFilterContext.Provider>\n        </DataTableColumnRankContext.Provider>\n      ))}\n      <li className=\"text-center mt-2 px-3\">\n        <Button\n          variant=\"outline\"\n          size=\"sm\"\n          onClick={() => {\n            setColumnRanks(undefined);\n            setHiddenColumns(defaultHiddenColumns);\n          }}\n        >\n          Reset\n        </Button>\n      </li>\n    </ul>,\n    container,\n  );\n};\n\ninterface ColumnsSelectorProps {\n  children?: React.ReactNode;\n}\n\nexport const ColumnsSelectorItem = <\n  RecordType extends RaRecord<Identifier> = RaRecord<Identifier>,\n>({\n  source,\n  label,\n}: ColumnsSelectorItemProps<RecordType>) => {\n  const resource = useResourceContext();\n  const { storeKey, defaultHiddenColumns } = useDataTableStoreContext();\n  const [hiddenColumns, setHiddenColumns] = useStore<string[]>(\n    storeKey,\n    defaultHiddenColumns,\n  );\n  const columnRank = useDataTableColumnRankContext();\n  const [columnRanks, setColumnRanks] = useStore<number[]>(\n    `${storeKey}_columnRanks`,\n  );\n  const columnFilter = useDataTableColumnFilterContext();\n  const translateLabel = useTranslateLabel();\n  if (!source && !label) return null;\n  const fieldLabel = translateLabel({\n    label: typeof label === \"string\" ? label : undefined,\n    resource,\n    source,\n  }) as string;\n  const isColumnHidden = hiddenColumns.includes(source!);\n  const isColumnFiltered = fieldLabelMatchesFilter(fieldLabel, columnFilter);\n\n  const handleMove = (\n    index1: number | string,\n    index2: number | string | null,\n  ) => {\n    const colRanks = !columnRanks\n      ? padRanks([], Math.max(Number(index1), Number(index2 || 0)) + 1)\n      : Math.max(Number(index1), Number(index2 || 0)) > columnRanks.length - 1\n        ? padRanks(\n            columnRanks,\n            Math.max(Number(index1), Number(index2 || 0)) + 1,\n          )\n        : columnRanks;\n    const index1Pos = colRanks.findIndex((index) => index == Number(index1));\n    const index2Pos = colRanks.findIndex((index) => index == Number(index2));\n    if (index1Pos === -1 || index2Pos === -1) {\n      return;\n    }\n    let newColumnRanks;\n    if (index1Pos > index2Pos) {\n      newColumnRanks = [\n        ...colRanks.slice(0, index2Pos),\n        colRanks[index1Pos],\n        ...colRanks.slice(index2Pos, index1Pos),\n        ...colRanks.slice(index1Pos + 1),\n      ];\n    } else {\n      newColumnRanks = [\n        ...colRanks.slice(0, index1Pos),\n        ...colRanks.slice(index1Pos + 1, index2Pos + 1),\n        colRanks[index1Pos],\n        ...colRanks.slice(index2Pos + 1),\n      ];\n    }\n    setColumnRanks(newColumnRanks);\n  };\n\n  return isColumnFiltered ? (\n    <FieldToggle\n      key={columnRank}\n      source={source!}\n      label={fieldLabel}\n      index={String(columnRank)}\n      selected={!isColumnHidden}\n      onToggle={() =>\n        isColumnHidden\n          ? setHiddenColumns(\n              hiddenColumns.filter((column) => column !== source!),\n            )\n          : setHiddenColumns([...hiddenColumns, source!])\n      }\n      onMove={handleMove}\n    />\n  ) : null;\n};\n\n// this is the same interface as DataTableColumnProps\n// but we copied it here to avoid circular dependencies with data-table\nexport interface ColumnsSelectorItemProps<\n  RecordType extends RaRecord<Identifier> = RaRecord<Identifier>,\n> {\n  className?: string;\n  cellClassName?: string;\n  headerClassName?: string;\n  conditionalClassName?: (record: RecordType) => string | false | undefined;\n  children?: ReactNode;\n  render?: (record: RecordType) => React.ReactNode;\n  field?: React.ElementType;\n  source?: NoInfer<HintedString<ExtractRecordPaths<RecordType>>>;\n  label?: React.ReactNode;\n  disableSort?: boolean;\n  sortByOrder?: SortPayload[\"order\"];\n}\n// Function to help with column ranking\nconst padRanks = (ranks: number[], length: number) =>\n  ranks.concat(\n    Array.from({ length: length - ranks.length }, (_, i) => ranks.length + i),\n  );\n\nconst fieldLabelMatchesFilter = (fieldLabel: string, columnFilter?: string) =>\n  columnFilter\n    ? diacritic\n        .clean(fieldLabel)\n        .toLowerCase()\n        .includes(diacritic.clean(columnFilter).toLowerCase())\n    : true;\n",
			"type": "components:ui"
		}
	],
	"tailwind": {
		"config": {}
	}
}
