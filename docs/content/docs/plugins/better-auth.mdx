---
title: Better Auth Integration
description: Integration plugin for Better Auth with Better Query
---

The Better Auth Integration plugin provides seamless authentication and authorization for your Better Query resources. It automatically handles user authentication, role-based permissions, and organization-based access control for all CRUD operations.

## Installation

<Steps>
  <Step>
    ### Set up Better Auth

    First, set up Better Auth in your application:

    ```ts title="auth.ts"
    import { betterAuth } from "better-auth"

    export const auth = betterAuth({
        database: {
            provider: "sqlite",
            url: "auth.db",
        },
        secret: process.env.BETTER_AUTH_SECRET,
        emailAndPassword: {
            enabled: true,
        },
        session: {
            expiresIn: 60 * 60 * 24 * 7, // 7 days
        },
    })
    ```

  </Step>

  <Step>
    ### Add Better Auth plugin to Better Query

    Add the Better Auth integration plugin to your query config:

    ```ts title="query.ts"
    import { betterQuery } from "better-query"
    import { betterAuthPlugin } from "better-query/plugins" // [!code highlight]
    import { auth } from "./auth" // [!code highlight]

    export const query = betterQuery({
        // ... other config options
        plugins: [
            betterAuthPlugin({
                auth, // Pass your Better Auth instance
                rolePermissions: {
                    admin: {
                        resources: ["*"], // Access to all resources
                        operations: ["create", "read", "update", "delete", "list"],
                        scopes: ["admin", "write", "read"]
                    },
                    moderator: {
                        resources: ["product", "category", "review"],
                        operations: ["read", "update", "list"],
                        scopes: ["moderate", "read"]
                    },
                    user: {
                        resources: ["product", "review"],
                        operations: ["read", "list"],
                        scopes: ["read"]
                    }
                }
            }) // [!code highlight]
        ]
    })
    ```

  </Step>

  <Step>
    ### Add the client plugin

    The Better Auth plugin works on the server side to handle authentication and permissions. No additional client configuration is required beyond the normal query client setup.

```ts title="query-client.ts"
import { createQueryClient } from "better-query/client"

export const queryClient = createQueryClient({
    baseURL: "http://localhost:3000/api"
})

// The server automatically handles authentication for all operations
// Requests will be authenticated based on session cookies or headers
const userProducts = await queryClient.product.list();
```
        ]
    })
    ```

  </Step>
</Steps>

## Authentication

### Automatic Authentication

With the plugin configured, all requests automatically include authentication:

```ts title="product-service.ts"
// Authentication headers are automatically added
const product = await queryClient.product.create({
    name: "New Product",
    price: 29.99
})

// The plugin automatically:
// 1. Gets the current session from Better Auth
// 2. Adds Authorization header with session token
// 3. Handles token refresh if needed
// 4. Redirects to login if not authenticated
```

### Manual Authentication Override

You can override authentication per request:

```ts title="product-service.ts"
// Use specific auth token
const product = await queryClient.product.read("product-123", {
    auth: {
        token: "custom-token"
    }
})

// Skip authentication (for public endpoints)
const publicProducts = await queryClient.product.list({}, {
    auth: {
        skip: true
    }
})
```

## Authorization

### Role-Based Permissions

Define permissions based on user roles:

```ts title="query.ts"
betterAuthPlugin({
    auth,
    rolePermissions: {
        // Super admin - access to everything
        superadmin: {
            resources: ["*"],
            operations: ["*"],
            scopes: ["*"]
        },
        
        // Admin - most resources with full access
        admin: {
            resources: ["user", "product", "category", "order"],
            operations: ["create", "read", "update", "delete", "list"],
            scopes: ["admin", "write", "read"]
        },
        
        // Manager - limited resources with write access
        manager: {
            resources: ["product", "category"],
            operations: ["create", "read", "update", "list"],
            scopes: ["write", "read"]
        },
        
        // User - read-only access to limited resources
        user: {
            resources: ["product", "category"],
            operations: ["read", "list"],
            scopes: ["read"]
        }
    }
})
```

### Resource-Level Permissions

Configure custom permissions per resource:

```ts title="query.ts"
import { betterQuery, createResource } from "better-query"

export const query = betterQuery({
    plugins: [betterAuthPlugin({ auth })],
    resources: [
        createResource({
            name: "product",
            schema: productSchema,
            permissions: {
                create: async (context) => {
                    // Only authenticated users can create products
                    return !!context.user
                },
                read: async (context) => {
                    // Anyone can read products (public)
                    return true
                },
                update: async (context) => {
                    const user = context.user as { role?: string; id: string }
                    // Admins or product owner can update
                    return user?.role === "admin" || 
                           context.existingData?.createdBy === user?.id
                },
                delete: async (context) => {
                    const user = context.user as { role?: string }
                    // Only admins can delete
                    return user?.role === "admin"
                },
                list: async (context) => {
                    // Anyone can list products
                    return true
                }
            }
        }),
        
        createResource({
            name: "order",
            schema: orderSchema,
            permissions: {
                create: async (context) => {
                    const user = context.user as { id: string }
                    // Users can only create orders for themselves
                    return user && context.data.userId === user.id
                },
                read: async (context) => {
                    const user = context.user as { role?: string; id: string }
                    // Admins can read all, users can read their own
                    if (user?.role === "admin") return true
                    const order = await getOrder(context.resourceId)
                    return order?.userId === user?.id
                },
                update: async (context) => {
                    const user = context.user as { role?: string }
                    // Only admins can update orders
                    return user?.role === "admin"
                },
                delete: async (context) => {
                    // No one can delete orders
                    return false
                },
                list: async (context) => {
                    // Only authenticated users can list orders
                    return !!context.user
                }
            }
        })
    ]
})
```

### Organization-Based Access

When using the Better Auth [organization plugin](/docs/plugins/organization), you can control access based on organization membership:

```ts title="query.ts"
betterAuthPlugin({
    auth,
    organizationPermissions: {
        // Organization admin permissions
        admin: {
            resources: ["project", "task", "member"],
            operations: ["create", "read", "update", "delete", "list"],
            scopes: ["org-admin"]
        },
        
        // Organization member permissions
        member: {
            resources: ["project", "task"],
            operations: ["read", "list"],
            scopes: ["org-member"]
        }
    },
    
    // Custom organization access logic
    organizationAccess: async (context) => {
        const user = context.user
        const orgId = context.headers["x-organization-id"]
        
        if (!user || !orgId) return false
        
        // Check if user belongs to the organization
        const membership = await auth.api.getUserOrgMembership({
            userId: user.id,
            organizationId: orgId
        })
        
        return !!membership
    }
})
```

### Scope-Based Permissions

Use scopes for fine-grained access control:

```ts title="query.ts"
createResource({
    name: "product",
    schema: productSchema,
    permissions: {
        create: async (context) => {
            // Check if user has 'product:create' scope
            return context.hasScope("product:create")
        },
        update: async (context) => {
            // Different update permissions based on scope
            if (context.hasScope("product:admin")) return true
            if (context.hasScope("product:update-own")) {
                return context.existingData?.createdBy === context.user?.id
            }
            return false
        },
        delete: async (context) => {
            // Only users with delete scope
            return context.hasScope("product:delete")
        }
    }
})
```

## Context Helpers

The Better Auth integration provides helpful context methods:

```ts title="resource-permissions.ts"
// In your permission functions, you have access to:
permissions: {
    create: async (context) => {
        // User information
        const user = context.user // Current authenticated user
        const userId = context.userId // User ID
        
        // Role checking
        const isAdmin = context.hasRole("admin")
        const hasAnyRole = context.hasAnyRole(["admin", "moderator"])
        
        // Organization checking  
        const belongsToOrg = context.belongsToOrg("org-123")
        const isOrgAdmin = context.isOrgAdmin("org-123")
        
        // Scope checking
        const hasScope = context.hasScope("product:create")
        const hasAnyScope = context.hasAnyScope(["read", "write"])
        
        // Request context
        const headers = context.headers
        const ip = context.request?.ip
        
        // Resource data
        const resourceData = context.data // Data being created/updated
        const existingData = context.existingData // Existing data (for updates)
        
        return true // or false based on your logic
    }
}
```

## Client-Side Authentication

### Automatic Session Handling

The client plugin automatically manages authentication:

```tsx title="components/product-manager.tsx"
import { useEffect, useState } from 'react'
import { queryClient } from '@/lib/query-client'

export function ProductManager() {
    const [products, setProducts] = useState([])
    const [error, setError] = useState(null)

    useEffect(() => {
        const fetchProducts = async () => {
            try {
                // Automatically includes auth headers
                const result = await queryClient.product.list()
                
                if (result.data) {
                    setProducts(result.data.items)
                } else if (result.error?.code === "UNAUTHORIZED") {
                    // Plugin automatically redirects to login
                    // Or you can handle it manually
                    window.location.href = "/login"
                }
            } catch (error) {
                setError(error.message)
            }
        }

        fetchProducts()
    }, [])

    return (
        <div>
            {error && <div>Error: {error}</div>}
            {products.map(product => (
                <div key={product.id}>{product.name}</div>
            ))}
        </div>
    )
}
```

### Manual Session Management

For more control over authentication:

```ts title="auth-service.ts"
import { queryClient } from '@/lib/query-client'
import { authClient } from '@/lib/auth-client'

// Check if user is authenticated before making requests
export async function createProduct(productData) {
    const session = await authClient.getSession()
    
    if (!session.data) {
        throw new Error("Not authenticated")
    }
    
    // Create product with explicit auth context
    return queryClient.product.create(productData, {
        auth: {
            session: session.data,
            // or token: session.data.token
        }
    })
}

// Handle token refresh
export async function createProductWithRefresh(productData) {
    try {
        return await queryClient.product.create(productData)
    } catch (error) {
        if (error.code === "TOKEN_EXPIRED") {
            // Refresh token
            await authClient.refreshSession()
            // Retry request
            return await queryClient.product.create(productData)
        }
        throw error
    }
}
```

### Permission-Based UI

Show/hide UI elements based on user permissions:

```tsx title="components/product-actions.tsx"
import { useAuthContext } from '@/hooks/use-auth-context'

export function ProductActions({ product }) {
    const { user, hasRole, hasScope, belongsToOrg } = useAuthContext()

    const canEdit = hasRole("admin") || 
                   hasScope("product:update") ||
                   (hasScope("product:update-own") && product.createdBy === user?.id)
                   
    const canDelete = hasRole("admin") || hasScope("product:delete")

    return (
        <div>
            {canEdit && (
                <button onClick={() => editProduct(product.id)}>
                    Edit
                </button>
            )}
            {canDelete && (
                <button onClick={() => deleteProduct(product.id)}>
                    Delete
                </button>
            )}
        </div>
    )
}
```

## Error Handling

Handle authentication and authorization errors:

```ts title="error-handling.ts"
import { queryClient } from '@/lib/query-client'

try {
    const result = await queryClient.product.create(productData)
} catch (error) {
    switch (error.code) {
        case "UNAUTHORIZED":
            // User not logged in
            redirect("/login")
            break
            
        case "FORBIDDEN":
            // User doesn't have permission
            showToast("You don't have permission to perform this action")
            break
            
        case "TOKEN_EXPIRED":
            // Session expired
            await authClient.refreshSession()
            // Retry the request
            break
            
        case "INVALID_SCOPE":
            // User missing required scope
            showToast("Insufficient privileges")
            break
            
        case "ORG_ACCESS_DENIED":
            // User not member of required organization
            showToast("Organization access required")
            break
            
        default:
            // Handle other errors
            showToast("An error occurred")
    }
}
```

## Advanced Configuration

### Custom Authentication Provider

Use custom authentication logic:

```ts title="query.ts"
betterAuthPlugin({
    auth,
    
    // Custom user resolver
    resolveUser: async (context) => {
        // Custom logic to get user from context
        const token = context.headers.authorization?.replace("Bearer ", "")
        if (!token) return null
        
        // Validate token and return user
        const user = await validateCustomToken(token)
        return user
    },
    
    // Custom permission checker
    checkPermission: async (user, operation, resource, context) => {
        // Implement custom permission logic
        const userPerms = await getUserPermissions(user.id)
        return userPerms.includes(`${resource}:${operation}`)
    },
    
    // Custom organization checker
    checkOrganizationAccess: async (user, orgId, requiredRole) => {
        const membership = await getOrgMembership(user.id, orgId)
        return membership && membership.role === requiredRole
    }
})
```

### Middleware Integration

Integrate with custom middleware:

```ts title="query.ts"
betterAuthPlugin({
    auth,
    
    // Run before permission checks
    beforePermissionCheck: async (context) => {
        // Log access attempts
        await logAccess({
            userId: context.user?.id,
            resource: context.resourceType,
            operation: context.operation,
            ip: context.request?.ip,
            timestamp: new Date()
        })
    },
    
    // Run after permission checks
    afterPermissionCheck: async (context, allowed) => {
        if (!allowed) {
            // Log permission denials
            await logPermissionDenial({
                userId: context.user?.id,
                resource: context.resourceType,
                operation: context.operation,
                reason: "insufficient_permissions"
            })
        }
    }
})
```

## Testing

Test your authentication and authorization logic:

```ts title="auth.test.ts"
import { describe, it, expect } from 'vitest'
import { testClient } from 'better-query/testing'
import { query } from './query'

describe('Better Auth Integration', () => {
    it('should allow admin to create products', async () => {
        const client = testClient(query, {
            user: { id: '1', role: 'admin' }
        })
        
        const result = await client.product.create({
            name: 'Test Product',
            price: 29.99
        })
        
        expect(result.data).toBeDefined()
        expect(result.error).toBeNull()
    })
    
    it('should deny regular user from creating products', async () => {
        const client = testClient(query, {
            user: { id: '2', role: 'user' }
        })
        
        const result = await client.product.create({
            name: 'Test Product',
            price: 29.99
        })
        
        expect(result.error?.code).toBe('FORBIDDEN')
    })
    
    it('should allow user to read their own orders', async () => {
        const client = testClient(query, {
            user: { id: '3', role: 'user' }
        })
        
        // Mock existing order
        await client.order.create({
            userId: '3',
            total: 99.99
        }, { bypassAuth: true })
        
        const result = await client.order.list()
        expect(result.data?.items).toHaveLength(1)
    })
})
```